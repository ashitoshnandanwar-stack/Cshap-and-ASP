Stateful versus stateless methods
In software development projects, the term state is used to describe the condition of the execution environment at a specific moment in time.
As your code executes line by line, values are stored in variables. At any moment during execution, the current state of the application is the collection of all values stored in memory.
Some methods don't rely on the current state of the application to work properly. 
In other words, stateless methods are implemented so that they can work without referencing or changing any values already stored in memory. Stateless methods are also known as static methods.
Other methods, however, must have access to the state of the application to work properly. 

In other words, stateful methods are built in such a way that they rely on values stored in memory by previous lines of code that have already been executed.
Or they modify the state of the application by updating values or storing new values in memory. They're also known as instance methods.
Stateful (instance) methods keep track of their state in fields, which are variables defined on the class. Each new instance of the class gets its own copy of those fields in which to store state.

To call methods of a class in the .NET Class Library, you use the format ClassName.MethodName(), where the . symbol is the member access operator to access a method defined on the class, and the () symbols are the method invocation operators.
When calling a stateless method, you don't need to create a new instance of its class first.
When calling a stateful method, you need to create an instance of the class, and access the method on the object.
Use the new operator to create a new instance of a class.
An instance of a class is called as an object.

# Array
An array is a special type of variable that can hold multiple values of the same data type.
To declare the array and initialize values in a single statement, enter the following code:
c#
string[] fraudulentOrderIDs = [ "A123", "B456", "C789" ];
This example uses the Collection expression syntax, which was introduced in C# 12 and is supported in .NET 10.
You may also see an older syntax used to initialize an array.
C#
string[] fraudulentOrderIDs = { "A123", "B456", "C789" };
Notice that this older syntax uses curly braces {} to enclose the values of the array. Both syntaxes are valid.

int value = (int)1.5m; // casting truncates
Console.WriteLine(value);

int value2 = Convert.ToInt32(1.5m); // converting rounds up
Console.WriteLine(value2);

string[] values = { "12.3", "45", "ABC", "11", "DEF" };

decimal total = 0m;
string message = "";

foreach (var value in values)
{
    decimal number; // stores the TryParse "out" value
    if (decimal.TryParse(value, out number))
    {
        total += number;
    } else
    {
        message += value;
    }
}

Console.WriteLine($"Message: {message}");
Console.WriteLine($"Total: {total}");

```Output
Signed integral types:
sbyte  : -128 to 127
short  : -32768 to 32767
int    : -2147483648 to 2147483647
long   : -9223372036854775808 to 9223372036854775807

Unsigned integral types:
byte   : 0 to 255
ushort : 0 to 65535
uint   : 0 to 4294967295
ulong  : 0 to 18446744073709551615
```

Precision is the number of value places stored after the decimal point.

Because floating-point types can hold large numbers with precision, their values can be represented using "E notation",
which is a form of scientific notation that means "times 10 raised to the power of." 
So, a value like 5E+2 would be the value 500 because it's the equivalent of 5 * 10^2, or 5 x 102.

How reference types are different from value types
A value type variable stores its values directly in an area of storage called the stack. 
The stack is memory allocated to the code that is currently running on the CPU (also known as the stack frame, or activation frame). 
When the stack frame has finished executing, the values in the stack are removed.

A reference type variable stores its values in a separate memory region called the heap. 
The heap is a memory area that is shared across many applications running on the operating system at the same time. 
The .NET Runtime communicates with the operating system to determine what memory addresses are available, and requests an address where it can store the value. 
The .NET Runtime stores the value, and then returns the memory address to the variable. 
When your code uses the variable, the .NET Runtime seamlessly looks up the address stored in the variable, and retrieves the value that's stored there.

Value types can hold smaller values and are stored in the stack. 
Reference types can hold large values, and a new instance of a reference type is created using the new operator.
Reference type variables hold a reference (the memory address) to the actual value stored in the heap.
Reference types include arrays, strings, and classes.

Use the Clear() method to empty the values out of elements in the array.
Use the Resize() method to change the number of elements in the array, removing or adding elements from the end of the array.
New array elements and cleared elements are null, meaning they don't point to a value in memory.

To create an array, use methods like ToCharArray() and Split()
To turn the array back into a single string, use methods like Join(), or create a new string passing in an array of char.

string pangram = "The quick brown fox jumps over the lazy dog";

// Step 1
string[] message = pangram.Split(' ');

//Step 2
string[] newMessage = new string[message.Length];

// Step 3
for (int i = 0; i < message.Length; i++)
{
    char[] letters = message[i].ToCharArray();
    Array.Reverse(letters);
    newMessage[i] = new string(letters);
}

//Step 4
string result = String.Join(" ", newMessage);
Console.WriteLine(result);

Methods that add blank spaces for formatting purposes (PadLeft(), PadRight())
Methods that compare two strings or facilitate comparison (Trim(), TrimStart(), TrimEnd(), GetHashcode(), the Length property)
Methods that help you determine what's inside of a string, or even retrieve just a part of the string (Contains(), StartsWith(), EndsWith(), Substring())
Methods that change the content of the string by replacing, inserting, or removing parts (Replace(), Insert(), Remove())
Methods that turn a string into an array of strings or characters (Split(), ToCharArray())

Methods that add blank spaces for formatting purposes (PadLeft(), PadRight())
Methods that compare two strings or facilitate comparison (Trim(), TrimStart(), TrimEnd(), GetHashcode(), the Length property)
Methods that help you determine what's inside of a string, or even retrieve just a part of the string (Contains(), StartsWith(), EndsWith(), Substring())
Methods that change the content of the string by replacing, inserting, or removing parts (Replace(), Insert(), Remove())
Methods that turn a string into an array of strings or characters (Split(), ToCharArray())

The Substring() method needs the starting position and the number of characters, or length, to retrieve. 
So, you calculate the length in a temporary variable called length, and pass it with the openingPosition value to retrieve the string inside of the parenthesis.

This unit covered much material. Here's the most important things to remember:

IndexOf() gives you the first position of a character or string inside of another string.
IndexOf() returns -1 if it can't find a match.
Substring() returns just the specified portion of a string, using a starting position and optional length.
There's often more than one way to solve a problem. You used two separate techniques to find all instances of a given character or string.
Avoid hardcoded magic values. Instead, define a const variable. A constant variable's value can't be changed after initialization.
The result is close, however the output includes the opening parenthesis. 
In this exercise, the inclusion of the parenthesis isn't desired. 
To remove the parenthesis from output, you have to update the code to skip the index of the parenthesis itself
