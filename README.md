# C#
.NET C#

- Value types (int, float, long, double etc) are stored on the stack because they are small, fixed-size, and short-lived.
- Reference types (class, object, string, array etc) interface are stored on the heap because they are larger, dynamic, and shared across the program.
  
| Stack                              | Heap                         |
| ---------------------------------- | ---------------------------- |
| Fast memory                        | Slower than stack            |
| Automatically managed              | Managed by Garbage Collector |
| Stores method calls & local values | Stores objects               |
| Fixed size                         | Dynamic size                 |

- CTS (Common type system) = how data types are declared, used, and managed in the .NET Framework.
- CLS (Common language specification) = set of rules that .NET languages must follow to ensure language interoperability.

![swimlane-architecture-framework](https://github.com/user-attachments/assets/72d75789-4439-4b56-ad20-901a3cd90420)

- ILDASM (Intermediate Language Disassembler) is a .NET tool used to view the contents of a compiled assembly (.exe or .dll) in Intermediate Language (IL) form.
  
```
Why ILDASM is Used
To inspect IL code generated by the compiler
To view metadata (classes, methods, fields)
To examine the assembly manifest (name, version, references)
For debugging, learning, and security analysis

```
<hr>

## ğŸ”· METHODS IN C#

```
1ï¸âƒ£ Method Overloading
ğŸ”¹ Definition
Method Overloading means having multiple methods with the same name but different parameter lists.

ğŸ”¹ Conditions for Overloading
Different number of parameters
Different data types of parameters
Different order of parameters
âš  Changing only return type is NOT allowed

Eg.
class Calculator
{
    // Method 1
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    // Method 2 - ERROR! Cannot overload based on return type alone
    public double Calculate(int a, int b)  // âŒ COMPILATION ERROR
    {
        return a + b;
    }
}

class Calculator
{
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    public int Calculate(int a, int b, int c)  // âœ… Different parameter count
    {
        return a + b + c;
    }
}

// Usage
calc.Calculate(5, 10);      // Calls first method
calc.Calculate(5, 10, 15);  // Calls second method
```
```
2ï¸âƒ£ Optional Parameters
ğŸ”¹ Definition
Optional parameters allow a method to be called without passing all arguments.

ğŸ”¹ Rule
Optional parameters must have default values
They must appear after required parameters

Eg.
void Display(int x, int y = 10)
{
    Console.WriteLine(x + y);
}

Display(5);      // y = 10
Display(5, 20);  // y = 20
```

```
3ï¸âƒ£ Named Parameters & Positional Parameters

ğŸ”¹ Positional Parameters
Arguments are passed in the same order as parameters.

Eg.
void Show(int a, int b)
{
    Console.WriteLine(a + " " + b);
}

Show(10, 20);

ğŸ”¹ Named Parameters
Arguments are passed using parameter names, order does not matter.

Show(b: 20, a: 10);

ğŸ”¹ Benefits of Named Parameters
Improves readability
Avoids confusion in methods with many parameters

```

```
4ï¸âƒ£ Using params
ğŸ”¹ Definition
params allows passing a variable number of arguments to a method.
params must be last parameter
void Test(int x, params int[] y)   // âœ… Correct
void Test(params int[] y, int x)   // âŒ ERROR

ğŸ”¹ Rules
Must be an array
Only one params parameter allowed in the method
Must be the last parameter

Eg.
int Sum(params int[] numbers)
{
    int total = 0;
    foreach (int n in numbers)
        total += n;
    return total;
}

Sum(1, 2, 3); //6
Sum(10, 20, 30, 40);  //100
Sum();   //no output

ğŸ”¹ Internally
Sum(1,2,3) â†’ Sum(new int[]{1,2,3});

```

```
5ï¸âƒ£ Local Functions
ğŸ”¹ Definition
A local function is a method defined inside another method.

ğŸ”¹ Purpose
Used for helper logic
Improves code readability
Scope limited to outer method

Eg.
void Calculate()
{
    int Square(int x)
    {
        return x * x;
    }

    Console.WriteLine(Square(5));
}

```
<hr>

## ğŸ”· PROPERTIES IN C#
- Properties are used to access class data safely.

```
1ï¸âƒ£ get and set Accessors
ğŸ”¹ Definition
get â†’ read value
set â†’ assign value

Eg.
class Student
{
    private int age;

    public int Age
    {
        get { return age; }
        set { age = value; }
    }
}

property without getter is invalid
public int Age { get; }   // âœ… Valid
public int Age { set; }   // âŒ Invalid
A property MUST have get accessor.
```

```
2ï¸âƒ£ Readonly Properties
ğŸ”¹ Definition
A readonly property allows only reading, not writing.

ğŸ”¹ Using only get
âœ” Value can be assigned only via constructor

Eg.
class Employee
{
    public int Id { get; }

    public Employee(int id)
    {
        Id = id;
    }
}
```

```
3ï¸âƒ£ Creating Readonly Property using Accessors

Eg.
class Circle
{
    private double radius = 5;

    public double Area
    {
        get
        {
            return 3.14 * radius * radius;
        }
    }
}

âœ” No set accessor
âœ” Computed value
âœ” Read-only
```

| Topic               | Key Point                       |
| ------------------- | ------------------------------- |
| Method Overloading  | Same name, different parameters |
| Optional Parameters | Default value provided          |
| Named Parameters    | Order independent               |
| params              | Variable arguments              |
| Local Functions     | Method inside method            |
| Properties          | Encapsulation                   |
| Readonly Property   | Only `get`, no `set`            |

<hr>

## Encapsulation
- Encapsulation = Hidden Data + Access Through Methods/Properties
- hiding the internal details from the outside world.

```
âœ… Hidden Data (Private)
class Student
{
    private int marks;  // ğŸ”’ HIDDEN - Cannot access directly from outside
}
```
```
âœ… Access Through Methods
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC METHODS
    public void SetMarks(int m)  // âœ… Method to SET data
    {
        if(m >= 0 && m <= 100)
            marks = m;
    }
    
    public int GetMarks()  // âœ… Method to GET data
    {
        return marks;
    }
}

// Usage
Student s = new Student();
s.SetMarks(85);  // âœ… Access through method
Console.WriteLine(s.GetMarks());  // âœ… Access through method

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```
```
âœ… Access Through Properties (Getter/Setter)
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC PROPERTY (Getter/Setter)
    public int Marks
    {
        get { return marks; }     // âœ… Getter
        set                        // âœ… Setter
        { 
            if(value >= 0 && value <= 100)
                marks = value; 
        }
    }
}

// Usage
Student s = new Student();
s.Marks = 85;  // âœ… Access through setter
Console.WriteLine(s.Marks);  // âœ… Access through getter

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```

```
## Simple Visual Understanding ğŸ¯

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CLASS (Student)            â”‚
â”‚                                     â”‚
â”‚    private int marks;  (HIDDEN)     â”‚
â”‚                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  PUBLIC DOOR (Methods)      â”‚   â”‚
â”‚   â”‚                             â”‚   â”‚
â”‚   â”‚  SetMarks() â† Enter here    â”‚   â”‚
â”‚   â”‚  GetMarks() â† Exit here     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘
        â”‚
    Outside world can only use these methods
    Cannot directly touch the marks variable
```
<hr>

## ğŸ”· CONSTRUCTORS (C#)
ğŸ”¹ What is a Constructor?
- A constructor is a special method that:
- Has the same name as the class
- Has no return type
- Is called automatically when an object is created
- Used to initialize data members

### ğŸ”¹ Types of Constructors

```
1ï¸âƒ£ Default Constructor
Eg.
class Student
{
    public Student()
    {
        Console.WriteLine("Constructor called");
    }
}

âœ” Called when object is created
âœ” If no constructor is written, C# provides a default constructor
âœ” Destructor = Finalizer
```

```
2ï¸âƒ£ Parameterized Constructor
Eg.
class Student
{
    int id;

    public Student(int i)
    {
        id = i;
    }
}

âœ” Used to initialize object with values
```
```
3ï¸âƒ£ Static Constructor
Eg.
class Demo
{
    static Demo()
    {
        Console.WriteLine("Static constructor");
    }
}

âœ” Called only once
âœ” Used to initialize static data
âœ” No access modifiers allowed
âœ” Cannot take parameters
```
```
ğŸ”‘ Exam Points
Constructor has no return type
Can be overloaded
Cannot be virtual or abstract
```
<hr>

## ğŸ”· OBJECT INITIALIZER

ğŸ”¹What is Object Initializer?
- Object initializer allows setting public properties or fields at the time of object creation without calling constructor explicitly.
```
Eg.
class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
}

Student s = new Student
{
    Id = 101,
    Name = "Amit"
};
âœ” Constructor is still called
âœ” Improves readability
âœ” Uses properties, not private fields
```
| Constructor                | Object Initializer         |
| -------------------------- | -------------------------- |
| Initializes via parameters | Initializes via properties |
| Logic allowed              | Only assignments           |
| Mandatory values           | Optional                   |

<hr>

## ğŸ”· DESTRUCTORS

ğŸ”¹ What is Destructor?
- A destructor:
- Is used to release unmanaged resources
- Is called automatically by Garbage Collector
- Is executed before object is destroyed

```
Syntax
class Test
{
    ~Test()
    {
        Console.WriteLine("Destructor called");
    }
}

ğŸ”‘ Rules (MCQ Favorite)
Destructor name is ~ClassName
Cannot have parameters
Cannot be overloaded
Called non-deterministically

```
<hr>

## ğŸ”· IDisposable INTERFACE

```
ğŸ”¹ Why IDisposable?
Garbage Collector:
Manages managed memory
Does NOT immediately free unmanaged resources
ğŸ‘‰ IDisposable is used to manually release resources like:
File handles
Database connections
Network sockets
```
```
ğŸ”¹ IDisposable Interface
public interface IDisposable
{
    void Dispose();
}

ğŸ”¹ Implementation Example
class FileHandler : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Resources released");
    }
}

ğŸ”¹ Using using Statement
using (FileHandler fh = new FileHandler())
{
    // use resource
}


âœ” Dispose() is called automatically
âœ” Ensures deterministic cleanup
```
| Destructor        | IDisposable          |
| ----------------- | -------------------- |
| Non-deterministic | Deterministic        |
| GC dependent      | Developer controlled |
| Slow              | Fast                 |
| Backup cleanup    | Primary cleanup      |

<hr>

## ğŸ”· STATIC MEMBERS OF A CLASS (C#)
```
ğŸ”¹ What does static mean?
static members belong to the class, not to objects.
Only one copy exists in memory.
Accessed using ClassName, not object.
```
```
ğŸ”¹ STATIC FIELDS
âœ… Definition
A static field is a variable shared by all objects of a class.

âœ… Example
class Student
{
    public static int count = 0;

    public Student()
    {
        count++;
    }
}

Student s1 = new Student();
Student s2 = new Student();

Console.WriteLine(Student.count); // 2

ğŸ”‘ Exam Points
Single copy for whole class
Used for common data
Initialized only once
```

```
ğŸ”¹ STATIC METHODS
âœ… Definition
A static method:
Can be called without creating object
Can access only static members

âœ… Example
class MathUtils
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}

Console.WriteLine(MathUtils.Add(10, 20));

Static methods cannot access instance members directly
```

```
ğŸ”¹ STATIC PROPERTIES
âœ… Definition

A static property belongs to the class and accesses static data.

âœ… Example
class Company
{
    private static string name;

    public static string Name
    {
        get { return name; }
        set { name = value; }
    }
}

Company.Name = "CDAC";
Console.WriteLine(Company.Name);

ğŸ”‘ Exam Points
Uses get / set
Accessed via class name
Used for global-like values
```
```
ğŸ”¹ STATIC CONSTRUCTORS
âœ… Definition

A static constructor initializes static members.

âœ… Example
class Demo
{
    static int x;

    static Demo()
    {
        x = 100;
    }
}

ğŸ”‘ RULES (VERY IMPORTANT)
Runs only once
No parameters
No access modifiers
Called automatically
Executes before first object or static access
```

```
ğŸ”¹ STATIC CLASSES
âœ… Definition
A static class:
Contains only static members
Cannot be instantiated using object
Cannot be inherited

âœ… Example
static class Utility
{
    public static void Show()
    {
        Console.WriteLine("Static class");
    }
}

Utility.Show();

âŒ Invalid
Utility u = new Utility(); // âŒ ERROR
```
```
ğŸ”¹ STATIC LOCAL FUNCTIONS
âœ… Definition
A static local function:
Is defined inside a method
Can access only static variables
Cannot capture local variables

âœ… Example
class Test
{
    static int x = 10;

    static void Display()
    {
        static int Square(int n)
        {
            return n * n;
        }

        Console.WriteLine(Square(x));
    }
}

ğŸ”‘ Why Static Local Functions?
Better performance
Avoid capturing outer variables
Clear scope

```

| Feature       | Static           | Instance        |
| ------------- | ---------------- | --------------- |
| Belongs to    | Class            | Object          |
| Memory        | One copy         | Multiple copies |
| Access        | ClassName.Member | Object.Member   |
| Object needed |  No              |  Yes            |

<hr>

## ğŸ”· INHERITANCE IN C#

```
ğŸ”¹ What is Inheritance?
Inheritance allows a class (derived/child) to acquire the properties and methods of another class (base/parent).

ğŸ”¹ Syntax
class Base { }
class Derived : Base { }

ğŸ”‘ Benefits
Code reusability
Extensibility
Supports runtime polymorphism


| Access Specifier     | Same Class | Derived Class   | Outside Class      |
| -------------------- | ---------- | -------------   | -----------------  |
| `public`             | âœ”          | âœ”              | âœ”                  |
| `protected`          | âœ”          | âœ”              | âŒ                 |
| `internal`           | âœ”          | âœ”              | âœ” (same assembly)  |
| `private`            | âœ”          | âŒ             | âŒ                 |
| `protected internal` | âœ”          | âœ”              | âœ”                  |
```
```
ğŸ”¹ CONSTRUCTORS IN AN INHERITANCE HIERARCHY
ğŸ”¹ Rule
Base class constructor is executed FIRST
Then derived class constructor

ğŸ”¹ Example
class A
{
    public A()
    {
        Console.WriteLine("Base");
    }
}

class B : A
{
    public B()
    {
        Console.WriteLine("Derived");
    }
}

Output
Base
Derived

ğŸ”‘ Important Rule

Constructor execution order: Base â†’ Derived
```
```
ğŸ”¹ OVERLOADING IN DERIVED CLASS
ğŸ”¹ Definition
Derived class can have methods with same name but different parameters.

ğŸ”¹ Example
class Base
{
    public void Show(int x) { }
}

class Derived : Base
{
    public void Show(int x, int y) { }
}


âœ” This is method overloading, NOT overriding.
```

```
ğŸ”¹ METHOD HIDING (new KEYWORD)
ğŸ”¹ Definition
When derived class defines a method with same signature as base class without override, it hides the base method.

ğŸ”¹ Example
class Base
{
    public void Display()
    {
        Console.WriteLine("Base");
    }
}

class Derived : Base
{
    public new void Display()
    {
        Console.WriteLine("Derived");
    }
}

ğŸ”¹ Method Call
Base b = new Derived();
b.Display();     // Base

Derived d = new Derived();
d.Display();     // Derived

ğŸ”‘ Exam Rule

Method hiding is compile-time binding
```
```
ğŸ”¹ METHOD OVERRIDING (override)
ğŸ”¹ Definition
Overriding means redefining a base class method in derived class using override.

ğŸ”¹ Rules
Base method must be marked virtual
Derived method must use override
Same signature required

ğŸ”¹ Example
class Base
{
    public virtual void Show()
    {
        Console.WriteLine("Base");
    }
}

class Derived : Base
{
    public override void Show()
    {
        Console.WriteLine("Derived");
    }
}

Method hiding happens when:
Derived class defines a method with same signature
Uses new keyword

class Base
{
    public void Display() { }
}

class Derived : Base
{
    public new void Display() { }
}

â­ Exam Rule
Method hiding â†’ uses new, not virtual
ğŸ”¹ Method Call
Base b = new Derived();
b.Show();   // Derived

ğŸ”‘ Exam Rule
Overriding supports runtime polymorphism
```

```
ğŸ”¹ SEALED METHODS
ğŸ”¹ Definition
A sealed method:
Cannot be overridden further
Used to stop further overriding

ğŸ”¹ Example
class A
{
    public virtual void Show() { }
}

class B : A
{
    public sealed override void Show() { }
}

class C : B
{
    // public override void Show() âŒ ERROR
}

ğŸ”‘ Exam Rule
sealed is used with override
```

```
ABSTRACT CLASSES
ğŸ”¹ Definition
An abstract class:
Cannot be instantiated
Can contain abstract + non-abstract methods

ğŸ”¹ Example
abstract class Shape
{
    public abstract void Draw();

    public void Info()
    {
        Console.WriteLine("Shape");
    }
}
```

```
 ABSTRACT METHODS
ğŸ”¹ Definition
Abstract method:
Has no body
Must be overridden in derived class

ğŸ”¹ Example
class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Circle");
    }
}

ğŸ”‘ Exam Rule

Derived class must override all abstract methods
```

```
 SEALED CLASSES
ğŸ”¹ Definition
A sealed class:
Cannot be inherited

ğŸ”¹ Example
sealed class Security { }

// class Test : Security âŒ ERROR
```

| Feature      | Overloading  | Overriding         | Hiding       |
| ------------ | ------------ | ------------------ | ------------ |
| Polymorphism | Compile-time | Runtime            | Compile-time |
| Keywords     | None         | virtual + override | new          |
| Signature    | Different    | Same               | Same         |

```
What does different signature mean?
A method signature consists of:
Method name
Number of parameters
Type of parameters
Order of parameters

ğŸ”´ Return type is NOT part of the method signature
```
<hr>

## ğŸ”· INTERFACES IN C#
```
ğŸ”¹ What is an Interface?
An interface is a contract that defines what a class must do, not how it does it.

ğŸ”¹ Key Characteristics
Contains method declarations, not implementations (mostly)
Supports multiple inheritance
All members are public by default
Cannot be instantiated

ğŸ”¹ Interface Syntax
interface IShape
{
    void Draw();
}

class Circle : IShape
{
    public void Draw()
    {
        Console.WriteLine("Drawing Circle");
    }
}

ğŸ”¹ Exam Rules (VERY IMPORTANT)
Interface name usually starts with I
Methods have no body (except default methods)
A class must implement all interface methods

```

### ğŸ”· IMPLEMENTING AN INTERFACE
```
ğŸ”¹ Rule
When a class implements an interface:
It must implement all methods
Methods must be public

ğŸ”¹ Example
interface IPrinter
{
    void Print();
}

class LaserPrinter : IPrinter
{
    public void Print()
    {
        Console.WriteLine("Printing...");
    }
}

ğŸ”‘ Exam Trap
âŒ Missing public causes compile-time error
```

### ğŸ”· EXPLICIT INTERFACE IMPLEMENTATION
```
ğŸ”¹ Why Explicit Implementation?
Used when:
Two interfaces have same method name
You want to hide interface method from class object
Avoid method name conflicts âœ…
ğŸ”¹ Example
interface IA
{
    void Show();
}

interface IB
{
    void Show();
}

class Test : IA, IB
{
    void IA.Show()
    {
        Console.WriteLine("IA Show");
    }

    void IB.Show()
    {
        Console.WriteLine("IB Show");
    }
}

ğŸ”¹ Method Call
IA a = new Test();
a.Show();   // IA Show

IB b = new Test();
b.Show();   // IB Show

ğŸ”‘ Exam Rule
Explicit interface methods cannot be called using class object

```

### ğŸ”· INHERITANCE IN INTERFACES
```
ğŸ”¹ Rule
One interface can inherit multiple interfaces
Interfaces inherit only declarations, not implementations

ğŸ”¹ Example
interface IA
{
    void A();
}

interface IB
{
    void B();
}

interface IC : IA, IB
{
    void C();
}

class Demo : IC
{
    public void A() { }
    public void B() { }
    public void C() { }
}

ğŸ”‘ Exam Point
Interfaces support multiple inheritance
```

### ğŸ”· DEFAULT INTERFACE METHODS (C# 8.0+)
```
ğŸ”¹ What are Default Interface Methods?
Interface methods with implementation.

ğŸ”¹ Why Introduced?
To add new methods to interface without breaking existing classes

ğŸ”¹ Example
interface ILogger
{
    void Log(string msg);

    void Info()
    {
        Console.WriteLine("Info log");
    }
}

class AppLogger : ILogger
{
    public void Log(string msg)
    {
        Console.WriteLine(msg);
    }
}


âœ” Info() need NOT be implemented
âœ” Can be overridden if needed

ğŸ”‘ Exam Trap
Default methods cannot access instance fields
Called using interface reference
Default methods allow adding new methods to interfaces without breaking existing classes.
Default interface methods â†’ Backward compatibility




```

### ğŸ”· OPERATOR OVERLOADING
```
ğŸ”¹ What is Operator Overloading?
Operator overloading allows custom behavior for operators (+, -, ==, etc.) for user-defined types.

ğŸ”¹ Rules
Only operators can be overloaded
At least one operand must be user-defined
Cannot overload . ?: sizeof
Operator overloading supports: Compile-time polymorphism âœ…
ğŸ”¹ Syntax
class Point
{
    public int x, y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static Point operator +(Point a, Point b)
    {
        return new Point(a.x + b.x, a.y + b.y);
    }
}

ğŸ”¹ Usage
Point p1 = new Point(2, 3);
Point p2 = new Point(4, 5);

Point p3 = p1 + p2;  // operator + called

ğŸ”‘ Operator Overloading Rules (MCQ FAVORITE)
Must be static
Cannot change operator precedence
Cannot overload new operators
```

| Feature              | Interface   | Abstract Class |
| -------------------- | ----------- | -------------- |
| Multiple inheritance |  Yes        |  No            |
| Constructors         |  No         |  Yes           |
| Fields               |  No         |  Yes           |
| Default methods      |  Yes        |  No            |
| Access modifier      | Public only |  Any           |

<hr>

## ğŸ”· REFERENCE TYPES vs VALUE TYPES (C#)

```
ğŸ”¹ Value Types
Store actual data
Stored in stack (mostly)
Copying creates a new independent copy
Changes do not affect original

Examples : 
int, float, double, char, bool
struct
enum

int a = 10;
int b = a;
b = 20;
// a = 10, b = 20
```

```
ğŸ”¹ Reference Types
Store reference (address) of data
Stored in heap
Copying copies reference
Changes affect same object

Examples : class, array, string, object, interface

int[] x = {1,2};
int[] y = x;
y[0] = 99;
// x[0] = 99
```

### ğŸ”· STRUCT (Value Type)
```
ğŸ”¹ What is struct?
User-defined value type
Cannot inherit other classes
Can implement interfaces
Faster and memory-efficient

Example
struct Point
{
    public int X;
    public int Y;
}

Point p1;
p1.X = 10;

ğŸ”‘ Exam Rules
Struct cannot have destructor
Struct cannot inherit class
Struct supports value semantics
```

### ğŸ”· ENUM (Value Type)
```
ğŸ”¹ What is enum?
Set of named constants
Underlying type is int by default

Example
enum Day
{
    Monday, Tuesday, Wednesday
}

Day d = Day.Monday;

Custom Values
enum Status
{
    Success = 1,
    Failure = 0
}
```

### ğŸ”· ref and out KEYWORDS
```
ğŸ”¹ ref
Variable must be initialized
Allows method to modify original variable

void Change(ref int x)
{
    x = 100;
}
int a = 10;
Change(ref a);
// a = 100


ğŸ”¹ out
Variable need NOT be initialized
Method must assign value
void GetValue(out int x)
{
    x = 50;
}

int a;
GetValue(out a);
// a = 50

| Feature                     | ref | out |
| --------------------------- | --- | --- |
| Must initialize before call | Yes | No  |
| Must assign inside method   | No  | Yes |

```

### ğŸ”· NULLABLE VALUE TYPES
```
ğŸ”¹ Problem
Value types cannot store null.
int x = null; // âŒ Error

ğŸ”¹ Solution: Nullable Value Types
int? x = null;

Equivalent:
Nullable<int> x = null;

Properties
x.HasValue
x.Value
```

### ğŸ”· NULLABLE REFERENCE TYPES (C# 8.0+)
```
ğŸ”¹ Purpose
Avoid NullReferenceException.

Example
string? name = null;  // nullable reference
string city = "Pune"; // non-nullable

city = null; // âŒ warning

Enable Feature
#nullable enable
```

### ğŸ”· NULL-COALESCING OPERATORS (?? and ??=)
```
ğŸ”¹ ?? Operator
Returns right value if left is null.

string name = null;
string result = name ?? "Guest";
// result = "Guest"

ğŸ”¹ ??= Operator
Assigns value only if left is null.

string name = null;
name ??= "Admin";
// name = "Admin"

```

### ğŸ”· WORKING WITH ARRAYS
```
ğŸ”¹ Single-Dimensional Array
int[] a = {1,2,3};

ğŸ”¹ Multidimensional Array (Rectangular)
int[,] m = {
    {1,2},
    {3,4}
};
Access:
m[1,0]; // 3
```
```
ğŸ”¹ Jagged Array (Array of Arrays) in C#
ğŸ‘‰ What is a Jagged Array?
A Jagged Array is an array of arrays, where:
Each row is a separate array
Rows can have different lengths

ğŸ“Œ Unlike a 2D array (matrix), rows are not equal in size.

ğŸ”¹ Declaration
dataType[][] arrayName;


Example:
int[][] numbers;

ğŸ”¹ Initialization
1ï¸âƒ£ Step-by-step Initialization
int[][] arr = new int[3][];

arr[0] = new int[] { 1, 2 };
arr[1] = new int[] { 3, 4, 5 };
arr[2] = new int[] { 6, 7, 8, 9 };

âœ” Each row has different size


2ï¸âƒ£ Direct Initialization
int[][] arr =
{
    new int[] { 1, 2 },
    new int[] { 3, 4, 5 },
    new int[] { 6, 7, 8, 9 }
};

ğŸ”¹ Accessing Elements
Console.WriteLine(arr[2][1]);
Output : 7

ğŸ“Œ First index â†’ row
ğŸ“Œ Second index â†’ column inside that row

Example program :
using System;

class Program
{
    static void Main()
    {
        int[][] marks =
        {
            new int[] { 80, 85 },
            new int[] { 70, 75, 78 },
            new int[] { 90, 92, 95, 98 }
        };

        for (int i = 0; i < marks.Length; i++)
        {
            Console.Write("Student " + (i + 1) + ": ");
            for (int j = 0; j < marks[i].Length; j++)
            {
                Console.Write(marks[i][j] + " ");
            }
            Console.WriteLine();
        }
    }
}
```
| Feature     | Jagged Array    | 2D Array |
| ----------- | --------------- | -------- |
| Structure   | Array of arrays | Matrix   |
| Row size    | Different       | Same     |
| Memory      | Efficient       | Fixed    |
| Declaration | `int[][]`       | `int[,]` |


### ğŸ”· INDICES AND RANGES (C# 8.0+)
```
ğŸ”¹ Index (^)
Counts from end.

int[] a = {10,20,30,40};
Console.WriteLine(a[^1]); // 40

ğŸ”¹ Range (..)
Selects a slice.
var part = a[1..3]; // {20,30}

ğŸ”· INDEXERS
ğŸ”¹ What is an Indexer?
Allows object to be accessed like an array.

Example
class Data
{
    int[] arr = new int[5];

    public int this[int index]
    {
        get { return arr[index]; }
        set { arr[index] = value; }
    }
}

Usage:
Data d = new Data();
d[0] = 100;
Console.WriteLine(d[0]);
```
```
ğŸ”‘ QUICK EXAM SUMMARY
Value types â†’ stack, copy by value
Reference types â†’ heap, copy by reference
struct, enum â†’ value types
ref â†’ initialized before call
out â†’ initialized inside method
int? â†’ nullable value type
string? â†’ nullable reference type
?? â†’ default if null
??= â†’ assign if null
Jagged â‰  Multidimensional
Indexers â†’ object behaves like array
Rank = number of dimensions
```

<hr>

## ğŸ”· GENERICS IN C#

### ğŸ”¹ Why Generics?
```
Generics allow you to:
Write type-safe code
Avoid boxing/unboxing
Improve performance
Reuse code for multiple data types

# What is Boxing and Unboxing?
ğŸ”¸ Boxing
Converting a value type (int, double, struct) into an object type
int x = 10;
object obj = x;   // BOXING

ğŸ”¸ Unboxing
Converting an object type back to value type
int y = (int)obj;   // UNBOXING

âš  These operations:
Use extra memory
Are slow
Can cause runtime exceptions
```

### ğŸ”¹ GENERIC CLASSES
```
âœ… Definition
A generic class works with a type parameter instead of a fixed data type.
Example
class Box<T>
{
    public T Value;
}
Box<int> b1 = new Box<int>();
b1.Value = 10;

Box<string> b2 = new Box<string>();
b2.Value = "CDAC";

ğŸ”‘ Exam Points
T is a type parameter
Same class works for multiple data types
Type safety ensured at compile time
```

### ğŸ”¹ GENERIC METHODS
```
âœ… Definition
A generic method defines type parameters at method level, not class level.

Example
class Test
{
    public void Show<T>(T data)
    {
        Console.WriteLine(data);
    }
}

Test t = new Test();
t.Show<int>(100);
t.Show<string>("Hello");

ğŸ”‘ Exam Trap
Generic method can exist inside non-generic class
```

### ğŸ”¹ GENERIC CONSTRAINTS
```
âœ… Definition
Constraints restrict what types can be used with generics.

Common Constraints
| **Constraint Syntax**  | **Meaning**                                          | **Allowed Types (Examples)**     |
| ---------------------- | ---------------------------------------------------- | -------------------------------- |
| `where T : class`      | `T` must be a **reference type**                     | `string`, `object`, custom class |
| `where T : struct`     | `T` must be a **value type**                         | `int`, `double`, `DateTime`      |
| `where T : new()`      | `T` must have a **public parameterless constructor** | `class A { public A(){} }`       |
| `where T : BaseClass`  | `T` must **inherit from a base class**               | `class Dog : Animal {}`          |
| `where T : IInterface` | `T` must **implement an interface**                  | `class A : IPrintable {}`        |


Example
class Sample<T> where T : class
{
    public T obj;
}

Multiple Constraints
âœ” You can apply more than one constraint
class Manager<T> where T : class, IPrintable, new()
{
}
```

### ğŸ”· COLLECTIONS IN C#
```
ğŸ”¹ Why Collections?
Collections store multiple elements dynamically (size can grow/shrink).

ğŸ”¹ NON-GENERIC COLLECTIONS (System.Collections)
| Collection  | Stores             |
| ----------- | ------------------ |
| `ArrayList` | object             |
| `Hashtable` | keyâ€“value (object) |
| `Stack`     | object             |
| `Queue`     | object             |

Drawback
âŒ No type safety
âŒ Boxing / Unboxing overhead

ğŸ”¹ GENERIC COLLECTIONS (System.Collections.Generic)
| Collection                | Stores    |
| ------------------------- | --------- |
| `List<T>`                 | T         |
| `Dictionary<TKey,TValue>` | keyâ€“value |
| `Stack<T>`                | T         |
| `Queue<T>`                | T         |

Advantages
âœ” Type safe
âœ” Better performance

```

### ICollection, IList, IDictionary (IMPORTANT)
```
ğŸ”¹ ICollection
Base interface for collections
Supports basic operations

Example:
ICollection<int> col = new List<int>();
col.Add(10);
col.Add(20);

Methods:
Add()
Remove()
Count

ğŸ”¹ IList
Ordered collection
Allows index-based access

Example
IList<string> list = new List<string>();
list.Add("A");
list.Add("B");
Console.WriteLine(list[0]);

ğŸ”¹ IDictionary
Stores keyâ€“value pairs
Keys must be unique

Generic Example
IDictionary<int, string> dict = new Dictionary<int, string>();
dict.Add(1, "One");

Non-Generic Example
IDictionary ht = new Hashtable();
ht.Add(1, "One");
```

### ğŸ”· ITERATING COLLECTIONS USING foreach
```
âœ… Rule
All collections implementing IEnumerable can be iterated using foreach.

Example
List<int> nums = new List<int> {1,2,3};
foreach (int n in nums)
{
    Console.WriteLine(n);
}

ğŸ”‘ Exam Rule
foreach is read-only (cannot modify collection structure)
```

### ğŸ”· TUPLES (Passing Multiple Values)
```
ğŸ”¹ Why Tuples?
To return or pass multiple values from/to a method without creating a class.

ğŸ”¹ Using Tuple (Old Style)
Tuple<int, string> GetData()
{
    return Tuple.Create(1, "CDAC");
}

ğŸ”¹ ValueTuple (Modern, Recommended)
(int, string) GetInfo()
{
    return (101, "Amit");
}

Call:
var data = GetInfo();
Console.WriteLine(data.Item1);
Console.WriteLine(data.Item2);

ğŸ”¹ Named Tuple Elements
(int id, string name) GetStudent()
{
    return (id: 1, name: "Ravi");
}

Access:
Console.WriteLine(data.id);
```

```
ğŸ”‘ QUICK EXAM SUMMARY
Generics â†’ type safety + performance
Generic class â†’ <T> at class level
Generic method â†’ <T> at method level
Constraints â†’ restrict generic types
Non-generic collections â†’ object based
Generic collections â†’ type safe
ICollection â†’ basic operations
IList â†’ index based
IDictionary â†’ keyâ€“value pairs
foreach â†’ iteration only
Tuples â†’ return multiple values
```

<hr>
