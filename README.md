# C#
.NET C#

- Value types (int, float, long, double etc) are stored on the stack because they are small, fixed-size, and short-lived.
- Reference types (class, object, string, array etc) interface are stored on the heap because they are larger, dynamic, and shared across the program.
  
| Stack                              | Heap                         |
| ---------------------------------- | ---------------------------- |
| Fast memory                        | Slower than stack            |
| Automatically managed              | Managed by Garbage Collector |
| Stores method calls & local values | Stores objects               |
| Fixed size                         | Dynamic size                 |

- CTS (Common type system) = how data types are declared, used, and managed in the .NET Framework.
- CLS (Common language specification) = set of rules that .NET languages must follow to ensure language interoperability.

![swimlane-architecture-framework](https://github.com/user-attachments/assets/72d75789-4439-4b56-ad20-901a3cd90420)

- ILDASM (Intermediate Language Disassembler) is a .NET tool used to view the contents of a compiled assembly (.exe or .dll) in Intermediate Language (IL) form.
  
```
Why ILDASM is Used
To inspect IL code generated by the compiler
To view metadata (classes, methods, fields)
To examine the assembly manifest (name, version, references)
For debugging, learning, and security analysis

```
<hr>

## ğŸ”· METHODS IN C#

```
1ï¸âƒ£ Method Overloading
ğŸ”¹ Definition
Method Overloading means having multiple methods with the same name but different parameter lists.

ğŸ”¹ Conditions for Overloading
Different number of parameters
Different data types of parameters
Different order of parameters
âš  Changing only return type is NOT allowed

Eg.
class Calculator
{
    // Method 1
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    // Method 2 - ERROR! Cannot overload based on return type alone
    public double Calculate(int a, int b)  // âŒ COMPILATION ERROR
    {
        return a + b;
    }
}

class Calculator
{
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    public int Calculate(int a, int b, int c)  // âœ… Different parameter count
    {
        return a + b + c;
    }
}

// Usage
calc.Calculate(5, 10);      // Calls first method
calc.Calculate(5, 10, 15);  // Calls second method
```
```
2ï¸âƒ£ Optional Parameters
ğŸ”¹ Definition
Optional parameters allow a method to be called without passing all arguments.

ğŸ”¹ Rule
Optional parameters must have default values
They must appear after required parameters

Eg.
void Display(int x, int y = 10)
{
    Console.WriteLine(x + y);
}

Display(5);      // y = 10
Display(5, 20);  // y = 20
```

```
3ï¸âƒ£ Named Parameters & Positional Parameters

ğŸ”¹ Positional Parameters
Arguments are passed in the same order as parameters.

Eg.
void Show(int a, int b)
{
    Console.WriteLine(a + " " + b);
}

Show(10, 20);

ğŸ”¹ Named Parameters
Arguments are passed using parameter names, order does not matter.

Show(b: 20, a: 10);

ğŸ”¹ Benefits of Named Parameters
Improves readability
Avoids confusion in methods with many parameters

```

```
4ï¸âƒ£ Using params
ğŸ”¹ Definition
params allows passing a variable number of arguments to a method.
params must be last parameter
void Test(int x, params int[] y)   // âœ… Correct
void Test(params int[] y, int x)   // âŒ ERROR

ğŸ”¹ Rules
Must be an array
Only one params parameter allowed in the method
Must be the last parameter

Eg.
int Sum(params int[] numbers)
{
    int total = 0;
    foreach (int n in numbers)
        total += n;
    return total;
}

Sum(1, 2, 3); //6
Sum(10, 20, 30, 40);  //100
Sum();   //no output

ğŸ”¹ Internally
Sum(1,2,3) â†’ Sum(new int[]{1,2,3});

```

```
5ï¸âƒ£ Local Functions
ğŸ”¹ Definition
A local function is a method defined inside another method.

ğŸ”¹ Purpose
Used for helper logic
Improves code readability
Scope limited to outer method

Eg.
void Calculate()
{
    int Square(int x)
    {
        return x * x;
    }

    Console.WriteLine(Square(5));
}

```
<hr>

## ğŸ”· PROPERTIES IN C#
- Properties are used to access class data safely.

```
1ï¸âƒ£ get and set Accessors
ğŸ”¹ Definition
get â†’ read value
set â†’ assign value

Eg.
class Student
{
    private int age;

    public int Age
    {
        get { return age; }
        set { age = value; }
    }
}

property without getter is invalid
public int Age { get; }   // âœ… Valid
public int Age { set; }   // âŒ Invalid
A property MUST have get accessor.
```

```
2ï¸âƒ£ Readonly Properties
ğŸ”¹ Definition
A readonly property allows only reading, not writing.

ğŸ”¹ Using only get
âœ” Value can be assigned only via constructor

Eg.
class Employee
{
    public int Id { get; }

    public Employee(int id)
    {
        Id = id;
    }
}
```

```
3ï¸âƒ£ Creating Readonly Property using Accessors

Eg.
class Circle
{
    private double radius = 5;

    public double Area
    {
        get
        {
            return 3.14 * radius * radius;
        }
    }
}

âœ” No set accessor
âœ” Computed value
âœ” Read-only
```

| Topic               | Key Point                       |
| ------------------- | ------------------------------- |
| Method Overloading  | Same name, different parameters |
| Optional Parameters | Default value provided          |
| Named Parameters    | Order independent               |
| params              | Variable arguments              |
| Local Functions     | Method inside method            |
| Properties          | Encapsulation                   |
| Readonly Property   | Only `get`, no `set`            |

<hr>

## Encapsulation
- Encapsulation = Hidden Data + Access Through Methods/Properties
- hiding the internal details from the outside world.

```
âœ… Hidden Data (Private)
class Student
{
    private int marks;  // ğŸ”’ HIDDEN - Cannot access directly from outside
}
```
```
âœ… Access Through Methods
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC METHODS
    public void SetMarks(int m)  // âœ… Method to SET data
    {
        if(m >= 0 && m <= 100)
            marks = m;
    }
    
    public int GetMarks()  // âœ… Method to GET data
    {
        return marks;
    }
}

// Usage
Student s = new Student();
s.SetMarks(85);  // âœ… Access through method
Console.WriteLine(s.GetMarks());  // âœ… Access through method

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```
```
âœ… Access Through Properties (Getter/Setter)
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC PROPERTY (Getter/Setter)
    public int Marks
    {
        get { return marks; }     // âœ… Getter
        set                        // âœ… Setter
        { 
            if(value >= 0 && value <= 100)
                marks = value; 
        }
    }
}

// Usage
Student s = new Student();
s.Marks = 85;  // âœ… Access through setter
Console.WriteLine(s.Marks);  // âœ… Access through getter

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```

```
## Simple Visual Understanding ğŸ¯

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CLASS (Student)            â”‚
â”‚                                     â”‚
â”‚    private int marks;  (HIDDEN)     â”‚
â”‚                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  PUBLIC DOOR (Methods)      â”‚   â”‚
â”‚   â”‚                             â”‚   â”‚
â”‚   â”‚  SetMarks() â† Enter here    â”‚   â”‚
â”‚   â”‚  GetMarks() â† Exit here     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘
        â”‚
    Outside world can only use these methods
    Cannot directly touch the marks variable
```
<hr>

## ğŸ”· CONSTRUCTORS (C#)
ğŸ”¹ What is a Constructor?
- A constructor is a special method that:
- Has the same name as the class
- Has no return type
- Is called automatically when an object is created
- Used to initialize data members

### ğŸ”¹ Types of Constructors

```
1ï¸âƒ£ Default Constructor
Eg.
class Student
{
    public Student()
    {
        Console.WriteLine("Constructor called");
    }
}

âœ” Called when object is created
âœ” If no constructor is written, C# provides a default constructor
âœ” Destructor = Finalizer
```

```
2ï¸âƒ£ Parameterized Constructor
Eg.
class Student
{
    int id;

    public Student(int i)
    {
        id = i;
    }
}

âœ” Used to initialize object with values
```
```
3ï¸âƒ£ Static Constructor
Eg.
class Demo
{
    static Demo()
    {
        Console.WriteLine("Static constructor");
    }
}

âœ” Called only once
âœ” Used to initialize static data
âœ” No access modifiers allowed
âœ” Cannot take parameters
```
```
ğŸ”‘ Exam Points
Constructor has no return type
Can be overloaded
Cannot be virtual or abstract
```
<hr>

## ğŸ”· OBJECT INITIALIZER

ğŸ”¹What is Object Initializer?
- Object initializer allows setting public properties or fields at the time of object creation without calling constructor explicitly.
```
Eg.
class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
}

Student s = new Student
{
    Id = 101,
    Name = "Amit"
};
âœ” Constructor is still called
âœ” Improves readability
âœ” Uses properties, not private fields
```
| Constructor                | Object Initializer         |
| -------------------------- | -------------------------- |
| Initializes via parameters | Initializes via properties |
| Logic allowed              | Only assignments           |
| Mandatory values           | Optional                   |

<hr>

## ğŸ”· DESTRUCTORS

ğŸ”¹ What is Destructor?
- A destructor:
- Is used to release unmanaged resources
- Is called automatically by Garbage Collector
- Is executed before object is destroyed

```
Syntax
class Test
{
    ~Test()
    {
        Console.WriteLine("Destructor called");
    }
}

ğŸ”‘ Rules (MCQ Favorite)
Destructor name is ~ClassName
Cannot have parameters
Cannot be overloaded
Called non-deterministically

```
<hr>

## ğŸ”· IDisposable INTERFACE

```
ğŸ”¹ Why IDisposable?
Garbage Collector:
Manages managed memory
Does NOT immediately free unmanaged resources
ğŸ‘‰ IDisposable is used to manually release resources like:
File handles
Database connections
Network sockets
```
```
ğŸ”¹ IDisposable Interface
public interface IDisposable
{
    void Dispose();
}

ğŸ”¹ Implementation Example
class FileHandler : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Resources released");
    }
}

ğŸ”¹ Using using Statement
using (FileHandler fh = new FileHandler())
{
    // use resource
}


âœ” Dispose() is called automatically
âœ” Ensures deterministic cleanup
```
| Destructor        | IDisposable          |
| ----------------- | -------------------- |
| Non-deterministic | Deterministic        |
| GC dependent      | Developer controlled |
| Slow              | Fast                 |
| Backup cleanup    | Primary cleanup      |

<hr>

## ğŸ”· STATIC MEMBERS OF A CLASS (C#)
```
ğŸ”¹ What does static mean?
static members belong to the class, not to objects.
Only one copy exists in memory.
Accessed using ClassName, not object.
```
```
ğŸ”¹ STATIC FIELDS
âœ… Definition
A static field is a variable shared by all objects of a class.

âœ… Example
class Student
{
    public static int count = 0;

    public Student()
    {
        count++;
    }
}

Student s1 = new Student();
Student s2 = new Student();

Console.WriteLine(Student.count); // 2

ğŸ”‘ Exam Points
Single copy for whole class
Used for common data
Initialized only once
```

```
ğŸ”¹ STATIC METHODS
âœ… Definition
A static method:
Can be called without creating object
Can access only static members

âœ… Example
class MathUtils
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}

Console.WriteLine(MathUtils.Add(10, 20));

Static methods cannot access instance members directly
```

```
ğŸ”¹ STATIC PROPERTIES
âœ… Definition

A static property belongs to the class and accesses static data.

âœ… Example
class Company
{
    private static string name;

    public static string Name
    {
        get { return name; }
        set { name = value; }
    }
}

Company.Name = "CDAC";
Console.WriteLine(Company.Name);

ğŸ”‘ Exam Points
Uses get / set
Accessed via class name
Used for global-like values
```
```
ğŸ”¹ STATIC CONSTRUCTORS
âœ… Definition

A static constructor initializes static members.

âœ… Example
class Demo
{
    static int x;

    static Demo()
    {
        x = 100;
    }
}

ğŸ”‘ RULES (VERY IMPORTANT)
Runs only once
No parameters
No access modifiers
Called automatically
Executes before first object or static access
```

```
ğŸ”¹ STATIC CLASSES
âœ… Definition
A static class:
Contains only static members
Cannot be instantiated using object
Cannot be inherited

âœ… Example
static class Utility
{
    public static void Show()
    {
        Console.WriteLine("Static class");
    }
}

Utility.Show();

âŒ Invalid
Utility u = new Utility(); // âŒ ERROR
```
```
ğŸ”¹ STATIC LOCAL FUNCTIONS
âœ… Definition
A static local function:
Is defined inside a method
Can access only static variables
Cannot capture local variables

âœ… Example
class Test
{
    static int x = 10;

    static void Display()
    {
        static int Square(int n)
        {
            return n * n;
        }

        Console.WriteLine(Square(x));
    }
}

ğŸ”‘ Why Static Local Functions?
Better performance
Avoid capturing outer variables
Clear scope

```

| Feature       | Static           | Instance        |
| ------------- | ---------------- | --------------- |
| Belongs to    | Class            | Object          |
| Memory        | One copy         | Multiple copies |
| Access        | ClassName.Member | Object.Member   |
| Object needed |  No              |  Yes            |
