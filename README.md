# C#
.NET C#

- Value types (int, float, long, double etc) are stored on the stack because they are small, fixed-size, and short-lived.
- Reference types (class, object, string, array etc) interface are stored on the heap because they are larger, dynamic, and shared across the program.
  
| Stack                              | Heap                         |
| ---------------------------------- | ---------------------------- |
| Fast memory                        | Slower than stack            |
| Automatically managed              | Managed by Garbage Collector |
| Stores method calls & local values | Stores objects               |
| Fixed size                         | Dynamic size                 |

- CTS (Common type system) = how data types are declared, used, and managed in the .NET Framework.
- CLS (Common language specification) = set of rules that .NET languages must follow to ensure language interoperability.

![swimlane-architecture-framework](https://github.com/user-attachments/assets/72d75789-4439-4b56-ad20-901a3cd90420)

- ILDASM (Intermediate Language Disassembler) is a .NET tool used to view the contents of a compiled assembly (.exe or .dll) in Intermediate Language (IL) form.
  
```
Why ILDASM is Used
To inspect IL code generated by the compiler
To view metadata (classes, methods, fields)
To examine the assembly manifest (name, version, references)
For debugging, learning, and security analysis

```
## üî∑ METHODS IN C#

```
1Ô∏è‚É£ Method Overloading
üîπ Definition
Method Overloading means having multiple methods with the same name but different parameter lists.

üîπ Conditions for Overloading
Different number of parameters
Different data types of parameters
Different order of parameters
‚ö† Changing only return type is NOT allowed

class Calculator
{
    // Method 1
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    // Method 2 - ERROR! Cannot overload based on return type alone
    public double Calculate(int a, int b)  // ‚ùå COMPILATION ERROR
    {
        return a + b;
    }
}

class Calculator
{
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    public int Calculate(int a, int b, int c)  // ‚úÖ Different parameter count
    {
        return a + b + c;
    }
}

// Usage
calc.Calculate(5, 10);      // Calls first method
calc.Calculate(5, 10, 15);  // Calls second method
```
