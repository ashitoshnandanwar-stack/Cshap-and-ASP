# C#
.NET C#

- Value types (int, float, long, double etc) are stored on the stack because they are small, fixed-size, and short-lived.
- Reference types (class, object, string, array etc) interface are stored on the heap because they are larger, dynamic, and shared across the program.
  
| Stack                              | Heap                         |
| ---------------------------------- | ---------------------------- |
| Fast memory                        | Slower than stack            |
| Automatically managed              | Managed by Garbage Collector |
| Stores method calls & local values | Stores objects               |
| Fixed size                         | Dynamic size                 |

- CTS (Common type system) = how data types are declared, used, and managed in the .NET Framework.
- CLS (Common language specification) = set of rules that .NET languages must follow to ensure language interoperability.

![swimlane-architecture-framework](https://github.com/user-attachments/assets/72d75789-4439-4b56-ad20-901a3cd90420)

- ILDASM (Intermediate Language Disassembler) is a .NET tool used to view the contents of a compiled assembly (.exe or .dll) in Intermediate Language (IL) form.
  
```
Why ILDASM is Used
To inspect IL code generated by the compiler
To view metadata (classes, methods, fields)
To examine the assembly manifest (name, version, references)
For debugging, learning, and security analysis

```
<hr>

## ğŸ”· METHODS IN C#

```
1ï¸âƒ£ Method Overloading
ğŸ”¹ Definition
Method Overloading means having multiple methods with the same name but different parameter lists.

ğŸ”¹ Conditions for Overloading
Different number of parameters
Different data types of parameters
Different order of parameters
âš  Changing only return type is NOT allowed

Eg.
class Calculator
{
    // Method 1
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    // Method 2 - ERROR! Cannot overload based on return type alone
    public double Calculate(int a, int b)  // âŒ COMPILATION ERROR
    {
        return a + b;
    }
}

class Calculator
{
    public int Calculate(int a, int b)
    {
        return a + b;
    }
    
    public int Calculate(int a, int b, int c)  // âœ… Different parameter count
    {
        return a + b + c;
    }
}

// Usage
calc.Calculate(5, 10);      // Calls first method
calc.Calculate(5, 10, 15);  // Calls second method
```
```
2ï¸âƒ£ Optional Parameters
ğŸ”¹ Definition
Optional parameters allow a method to be called without passing all arguments.

ğŸ”¹ Rule
Optional parameters must have default values
They must appear after required parameters

Eg.
void Display(int x, int y = 10)
{
    Console.WriteLine(x + y);
}

Display(5);      // y = 10
Display(5, 20);  // y = 20
```

```
3ï¸âƒ£ Named Parameters & Positional Parameters

ğŸ”¹ Positional Parameters
Arguments are passed in the same order as parameters.

Eg.
void Show(int a, int b)
{
    Console.WriteLine(a + " " + b);
}

Show(10, 20);

ğŸ”¹ Named Parameters
Arguments are passed using parameter names, order does not matter.

Show(b: 20, a: 10);

ğŸ”¹ Benefits of Named Parameters
Improves readability
Avoids confusion in methods with many parameters

```

```
4ï¸âƒ£ Using params
ğŸ”¹ Definition
params allows passing a variable number of arguments to a method.
params must be last parameter
void Test(int x, params int[] y)   // âœ… Correct
void Test(params int[] y, int x)   // âŒ ERROR

ğŸ”¹ Rules
Must be an array
Only one params parameter allowed in the method
Must be the last parameter

Eg.
int Sum(params int[] numbers)
{
    int total = 0;
    foreach (int n in numbers)
        total += n;
    return total;
}

Sum(1, 2, 3); //6
Sum(10, 20, 30, 40);  //100
Sum();   //no output

ğŸ”¹ Internally
Sum(1,2,3) â†’ Sum(new int[]{1,2,3});

```

```
5ï¸âƒ£ Local Functions
ğŸ”¹ Definition
A local function is a method defined inside another method.

ğŸ”¹ Purpose
Used for helper logic
Improves code readability
Scope limited to outer method

Eg.
void Calculate()
{
    int Square(int x)
    {
        return x * x;
    }

    Console.WriteLine(Square(5));
}

```
<hr>

## ğŸ”· PROPERTIES IN C#
- Properties are used to access class data safely.

```
1ï¸âƒ£ get and set Accessors
ğŸ”¹ Definition
get â†’ read value
set â†’ assign value

Eg.
class Student
{
    private int age;

    public int Age
    {
        get { return age; }
        set { age = value; }
    }
}

property without getter is invalid
public int Age { get; }   // âœ… Valid
public int Age { set; }   // âŒ Invalid
A property MUST have get accessor.
```

```
2ï¸âƒ£ Readonly Properties
ğŸ”¹ Definition
A readonly property allows only reading, not writing.

ğŸ”¹ Using only get
âœ” Value can be assigned only via constructor

Eg.
class Employee
{
    public int Id { get; }

    public Employee(int id)
    {
        Id = id;
    }
}
```

```
3ï¸âƒ£ Creating Readonly Property using Accessors

Eg.
class Circle
{
    private double radius = 5;

    public double Area
    {
        get
        {
            return 3.14 * radius * radius;
        }
    }
}

âœ” No set accessor
âœ” Computed value
âœ” Read-only
```

| Topic               | Key Point                       |
| ------------------- | ------------------------------- |
| Method Overloading  | Same name, different parameters |
| Optional Parameters | Default value provided          |
| Named Parameters    | Order independent               |
| params              | Variable arguments              |
| Local Functions     | Method inside method            |
| Properties          | Encapsulation                   |
| Readonly Property   | Only `get`, no `set`            |

<hr>

## Encapsulation
- Encapsulation = Hidden Data + Access Through Methods/Properties
- hiding the internal details from the outside world.

```
âœ… Hidden Data (Private)
class Student
{
    private int marks;  // ğŸ”’ HIDDEN - Cannot access directly from outside
}
```
```
âœ… Access Through Methods
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC METHODS
    public void SetMarks(int m)  // âœ… Method to SET data
    {
        if(m >= 0 && m <= 100)
            marks = m;
    }
    
    public int GetMarks()  // âœ… Method to GET data
    {
        return marks;
    }
}

// Usage
Student s = new Student();
s.SetMarks(85);  // âœ… Access through method
Console.WriteLine(s.GetMarks());  // âœ… Access through method

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```
```
âœ… Access Through Properties (Getter/Setter)
class Student
{
    private int marks;  // ğŸ”’ Hidden
    
    // Access through PUBLIC PROPERTY (Getter/Setter)
    public int Marks
    {
        get { return marks; }     // âœ… Getter
        set                        // âœ… Setter
        { 
            if(value >= 0 && value <= 100)
                marks = value; 
        }
    }
}

// Usage
Student s = new Student();
s.Marks = 85;  // âœ… Access through setter
Console.WriteLine(s.Marks);  // âœ… Access through getter

// s.marks = 85;  // âŒ ERROR! Cannot access directly
```

```
## Simple Visual Understanding ğŸ¯

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CLASS (Student)            â”‚
â”‚                                     â”‚
â”‚    private int marks;  (HIDDEN)     â”‚
â”‚                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  PUBLIC DOOR (Methods)      â”‚   â”‚
â”‚   â”‚                             â”‚   â”‚
â”‚   â”‚  SetMarks() â† Enter here    â”‚   â”‚
â”‚   â”‚  GetMarks() â† Exit here     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†‘
        â”‚
    Outside world can only use these methods
    Cannot directly touch the marks variable
```
<hr>

## ğŸ”· CONSTRUCTORS (C#)
ğŸ”¹ What is a Constructor?
- A constructor is a special method that:
- Has the same name as the class
- Has no return type
- Is called automatically when an object is created
- Used to initialize data members

### ğŸ”¹ Types of Constructors

```
1ï¸âƒ£ Default Constructor
Eg.
class Student
{
    public Student()
    {
        Console.WriteLine("Constructor called");
    }
}

âœ” Called when object is created
âœ” If no constructor is written, C# provides a default constructor
âœ” Destructor = Finalizer
```

```
2ï¸âƒ£ Parameterized Constructor
Eg.
class Student
{
    int id;

    public Student(int i)
    {
        id = i;
    }
}

âœ” Used to initialize object with values
```
```
3ï¸âƒ£ Static Constructor
Eg.
class Demo
{
    static Demo()
    {
        Console.WriteLine("Static constructor");
    }
}

âœ” Called only once
âœ” Used to initialize static data
âœ” No access modifiers allowed
âœ” Cannot take parameters
```
```
ğŸ”‘ Exam Points
Constructor has no return type
Can be overloaded
Cannot be virtual or abstract
```
<hr>

## ğŸ”· OBJECT INITIALIZER

ğŸ”¹What is Object Initializer?
- Object initializer allows setting public properties or fields at the time of object creation without calling constructor explicitly.
```
Eg.
class Student
{
    public int Id { get; set; }
    public string Name { get; set; }
}

Student s = new Student
{
    Id = 101,
    Name = "Amit"
};
âœ” Constructor is still called
âœ” Improves readability
âœ” Uses properties, not private fields
```
| Constructor                | Object Initializer         |
| -------------------------- | -------------------------- |
| Initializes via parameters | Initializes via properties |
| Logic allowed              | Only assignments           |
| Mandatory values           | Optional                   |

<hr>

## ğŸ”· DESTRUCTORS

ğŸ”¹ What is Destructor?
- A destructor:
- Is used to release unmanaged resources
- Is called automatically by Garbage Collector
- Is executed before object is destroyed

```
Syntax
class Test
{
    ~Test()
    {
        Console.WriteLine("Destructor called");
    }
}

ğŸ”‘ Rules (MCQ Favorite)
Destructor name is ~ClassName
Cannot have parameters
Cannot be overloaded
Called non-deterministically

```
<hr>

## ğŸ”· IDisposable INTERFACE

```
ğŸ”¹ Why IDisposable?
Garbage Collector:
Manages managed memory
Does NOT immediately free unmanaged resources
ğŸ‘‰ IDisposable is used to manually release resources like:
File handles
Database connections
Network sockets
```
```
ğŸ”¹ IDisposable Interface
public interface IDisposable
{
    void Dispose();
}

ğŸ”¹ Implementation Example
class FileHandler : IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Resources released");
    }
}

ğŸ”¹ Using using Statement
using (FileHandler fh = new FileHandler())
{
    // use resource
}


âœ” Dispose() is called automatically
âœ” Ensures deterministic cleanup
```
| Destructor        | IDisposable          |
| ----------------- | -------------------- |
| Non-deterministic | Deterministic        |
| GC dependent      | Developer controlled |
| Slow              | Fast                 |
| Backup cleanup    | Primary cleanup      |

<hr>

## ğŸ”· STATIC MEMBERS OF A CLASS (C#)
```
ğŸ”¹ What does static mean?
static members belong to the class, not to objects.
Only one copy exists in memory.
Accessed using ClassName, not object.
```
```
ğŸ”¹ STATIC FIELDS
âœ… Definition
A static field is a variable shared by all objects of a class.

âœ… Example
class Student
{
    public static int count = 0;

    public Student()
    {
        count++;
    }
}

Student s1 = new Student();
Student s2 = new Student();

Console.WriteLine(Student.count); // 2

ğŸ”‘ Exam Points
Single copy for whole class
Used for common data
Initialized only once
```

```
ğŸ”¹ STATIC METHODS
âœ… Definition
A static method:
Can be called without creating object
Can access only static members

âœ… Example
class MathUtils
{
    public static int Add(int a, int b)
    {
        return a + b;
    }
}

Console.WriteLine(MathUtils.Add(10, 20));

Static methods cannot access instance members directly
```

```
ğŸ”¹ STATIC PROPERTIES
âœ… Definition

A static property belongs to the class and accesses static data.

âœ… Example
class Company
{
    private static string name;

    public static string Name
    {
        get { return name; }
        set { name = value; }
    }
}

Company.Name = "CDAC";
Console.WriteLine(Company.Name);

ğŸ”‘ Exam Points
Uses get / set
Accessed via class name
Used for global-like values
```
```
ğŸ”¹ STATIC CONSTRUCTORS
âœ… Definition

A static constructor initializes static members.

âœ… Example
class Demo
{
    static int x;

    static Demo()
    {
        x = 100;
    }
}

ğŸ”‘ RULES (VERY IMPORTANT)
Runs only once
No parameters
No access modifiers
Called automatically
Executes before first object or static access
```

```
ğŸ”¹ STATIC CLASSES
âœ… Definition
A static class:
Contains only static members
Cannot be instantiated using object
Cannot be inherited

âœ… Example
static class Utility
{
    public static void Show()
    {
        Console.WriteLine("Static class");
    }
}

Utility.Show();

âŒ Invalid
Utility u = new Utility(); // âŒ ERROR
```
```
ğŸ”¹ STATIC LOCAL FUNCTIONS
âœ… Definition
A static local function:
Is defined inside a method
Can access only static variables
Cannot capture local variables

âœ… Example
class Test
{
    static int x = 10;

    static void Display()
    {
        static int Square(int n)
        {
            return n * n;
        }

        Console.WriteLine(Square(x));
    }
}

ğŸ”‘ Why Static Local Functions?
Better performance
Avoid capturing outer variables
Clear scope

```

| Feature       | Static           | Instance        |
| ------------- | ---------------- | --------------- |
| Belongs to    | Class            | Object          |
| Memory        | One copy         | Multiple copies |
| Access        | ClassName.Member | Object.Member   |
| Object needed |  No              |  Yes            |

<hr>

## ğŸ”· INHERITANCE IN C#

```
ğŸ”¹ What is Inheritance?
Inheritance allows a class (derived/child) to acquire the properties and methods of another class (base/parent).

ğŸ”¹ Syntax
class Base { }
class Derived : Base { }

ğŸ”‘ Benefits
Code reusability
Extensibility
Supports runtime polymorphism


| Access Specifier     | Same Class | Derived Class   | Outside Class      |
| -------------------- | ---------- | -------------   | -----------------  |
| `public`             | âœ”          | âœ”              | âœ”                  |
| `protected`          | âœ”          | âœ”              | âŒ                 |
| `internal`           | âœ”          | âœ”              | âœ” (same assembly)  |
| `private`            | âœ”          | âŒ             | âŒ                 |
| `protected internal` | âœ”          | âœ”              | âœ”                  |
```
```
ğŸ”¹ CONSTRUCTORS IN AN INHERITANCE HIERARCHY
ğŸ”¹ Rule
Base class constructor is executed FIRST
Then derived class constructor

ğŸ”¹ Example
class A
{
    public A()
    {
        Console.WriteLine("Base");
    }
}

class B : A
{
    public B()
    {
        Console.WriteLine("Derived");
    }
}

Output
Base
Derived

ğŸ”‘ Important Rule

Constructor execution order: Base â†’ Derived
```
```
ğŸ”¹ OVERLOADING IN DERIVED CLASS
ğŸ”¹ Definition
Derived class can have methods with same name but different parameters.

ğŸ”¹ Example
class Base
{
    public void Show(int x) { }
}

class Derived : Base
{
    public void Show(int x, int y) { }
}


âœ” This is method overloading, NOT overriding.
```

```
ğŸ”¹ METHOD HIDING (new KEYWORD)
ğŸ”¹ Definition
When derived class defines a method with same signature as base class without override, it hides the base method.

ğŸ”¹ Example
class Base
{
    public void Display()
    {
        Console.WriteLine("Base");
    }
}

class Derived : Base
{
    public new void Display()
    {
        Console.WriteLine("Derived");
    }
}

ğŸ”¹ Method Call
Base b = new Derived();
b.Display();     // Base

Derived d = new Derived();
d.Display();     // Derived

ğŸ”‘ Exam Rule

Method hiding is compile-time binding
```
```
ğŸ”¹ METHOD OVERRIDING (override)
ğŸ”¹ Definition
Overriding means redefining a base class method in derived class using override.

ğŸ”¹ Rules
Base method must be marked virtual
Derived method must use override
Same signature required

ğŸ”¹ Example
class Base
{
    public virtual void Show()
    {
        Console.WriteLine("Base");
    }
}

class Derived : Base
{
    public override void Show()
    {
        Console.WriteLine("Derived");
    }
}

Method hiding happens when:
Derived class defines a method with same signature
Uses new keyword

class Base
{
    public void Display() { }
}

class Derived : Base
{
    public new void Display() { }
}

â­ Exam Rule
Method hiding â†’ uses new, not virtual
ğŸ”¹ Method Call
Base b = new Derived();
b.Show();   // Derived

ğŸ”‘ Exam Rule
Overriding supports runtime polymorphism
```

```
ğŸ”¹ SEALED METHODS
ğŸ”¹ Definition
A sealed method:
Cannot be overridden further
Used to stop further overriding

ğŸ”¹ Example
class A
{
    public virtual void Show() { }
}

class B : A
{
    public sealed override void Show() { }
}

class C : B
{
    // public override void Show() âŒ ERROR
}

ğŸ”‘ Exam Rule
sealed is used with override
```

```
ABSTRACT CLASSES
ğŸ”¹ Definition
An abstract class:
Cannot be instantiated
Can contain abstract + non-abstract methods

ğŸ”¹ Example
abstract class Shape
{
    public abstract void Draw();

    public void Info()
    {
        Console.WriteLine("Shape");
    }
}
```

```
 ABSTRACT METHODS
ğŸ”¹ Definition
Abstract method:
Has no body
Must be overridden in derived class

ğŸ”¹ Example
class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Circle");
    }
}

ğŸ”‘ Exam Rule

Derived class must override all abstract methods
```

```
 SEALED CLASSES
ğŸ”¹ Definition
A sealed class:
Cannot be inherited

ğŸ”¹ Example
sealed class Security { }

// class Test : Security âŒ ERROR
```

| Feature      | Overloading  | Overriding         | Hiding       |
| ------------ | ------------ | ------------------ | ------------ |
| Polymorphism | Compile-time | Runtime            | Compile-time |
| Keywords     | None         | virtual + override | new          |
| Signature    | Different    | Same               | Same         |

```
What does different signature mean?
A method signature consists of:
Method name
Number of parameters
Type of parameters
Order of parameters

ğŸ”´ Return type is NOT part of the method signature
```
<hr>

## ğŸ”· INTERFACES IN C#
```
ğŸ”¹ What is an Interface?
An interface is a contract that defines what a class must do, not how it does it.

ğŸ”¹ Key Characteristics
Contains method declarations, not implementations (mostly)
Supports multiple inheritance
All members are public by default
Cannot be instantiated

ğŸ”¹ Interface Syntax
interface IShape
{
    void Draw();
}

class Circle : IShape
{
    public void Draw()
    {
        Console.WriteLine("Drawing Circle");
    }
}

ğŸ”¹ Exam Rules (VERY IMPORTANT)
Interface name usually starts with I
Methods have no body (except default methods)
A class must implement all interface methods

```

### ğŸ”· IMPLEMENTING AN INTERFACE
```
ğŸ”¹ Rule
When a class implements an interface:
It must implement all methods
Methods must be public

ğŸ”¹ Example
interface IPrinter
{
    void Print();
}

class LaserPrinter : IPrinter
{
    public void Print()
    {
        Console.WriteLine("Printing...");
    }
}

ğŸ”‘ Exam Trap
âŒ Missing public causes compile-time error
```

### ğŸ”· EXPLICIT INTERFACE IMPLEMENTATION
```
ğŸ”¹ Why Explicit Implementation?
Used when:
Two interfaces have same method name
You want to hide interface method from class object

ğŸ”¹ Example
interface IA
{
    void Show();
}

interface IB
{
    void Show();
}

class Test : IA, IB
{
    void IA.Show()
    {
        Console.WriteLine("IA Show");
    }

    void IB.Show()
    {
        Console.WriteLine("IB Show");
    }
}

ğŸ”¹ Method Call
IA a = new Test();
a.Show();   // IA Show

IB b = new Test();
b.Show();   // IB Show

ğŸ”‘ Exam Rule
Explicit interface methods cannot be called using class object

```

### ğŸ”· INHERITANCE IN INTERFACES
```
ğŸ”¹ Rule
One interface can inherit multiple interfaces
Interfaces inherit only declarations, not implementations

ğŸ”¹ Example
interface IA
{
    void A();
}

interface IB
{
    void B();
}

interface IC : IA, IB
{
    void C();
}

class Demo : IC
{
    public void A() { }
    public void B() { }
    public void C() { }
}

ğŸ”‘ Exam Point
Interfaces support multiple inheritance
```

### ğŸ”· DEFAULT INTERFACE METHODS (C# 8.0+)
```
ğŸ”¹ What are Default Interface Methods?
Interface methods with implementation.

ğŸ”¹ Why Introduced?
To add new methods to interface without breaking existing classes

ğŸ”¹ Example
interface ILogger
{
    void Log(string msg);

    void Info()
    {
        Console.WriteLine("Info log");
    }
}

class AppLogger : ILogger
{
    public void Log(string msg)
    {
        Console.WriteLine(msg);
    }
}


âœ” Info() need NOT be implemented
âœ” Can be overridden if needed

ğŸ”‘ Exam Trap
Default methods cannot access instance fields
Called using interface reference

```

### ğŸ”· OPERATOR OVERLOADING
```
ğŸ”¹ What is Operator Overloading?
Operator overloading allows custom behavior for operators (+, -, ==, etc.) for user-defined types.

ğŸ”¹ Rules
Only operators can be overloaded
At least one operand must be user-defined
Cannot overload . ?: sizeof

ğŸ”¹ Syntax
class Point
{
    public int x, y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    public static Point operator +(Point a, Point b)
    {
        return new Point(a.x + b.x, a.y + b.y);
    }
}

ğŸ”¹ Usage
Point p1 = new Point(2, 3);
Point p2 = new Point(4, 5);

Point p3 = p1 + p2;  // operator + called

ğŸ”‘ Operator Overloading Rules (MCQ FAVORITE)
Must be static
Cannot change operator precedence
Cannot overload new operators
```

| Feature              | Interface   | Abstract Class |
| -------------------- | ----------- | -------------- |
| Multiple inheritance |  Yes        |  No            |
| Constructors         |  No         |  Yes           |
| Fields               |  No         |  Yes           |
| Default methods      |  Yes        |  No            |
| Access modifier      | Public only |  Any           |

<hr>
